# [오픈소스응용프로그래밍] 23. 분기 검증 기준

<aside>

# 💖 분기 검증 기준

</aside>

## 분기 검증 기준(결정 검증 기준)

![image.png](image%2044.png)

모든 **분기**를 적어도 한 번씩은 거쳐 가도록 경로를 선정합니다.

- 우리가 앞에서 배운 문장 검증 기준은 모든 **문장**을 지나가도록 하는 경로를 선택하였습니다.
- 분기 검증 기준은 **조건문에 대해 T, F가 최소한 한 번씩은 실행되는 입력 데이터**를 테스트 케이스로 사용합니다.

## 분기 검증 기준의 단계

### 1. 제어 흐름 그래프 그리기

```jsx
foo(int X, int Y, int Z) {
  if (X > 1 && Y == 0) {
    Z = Z / X;
  }
  if (X == 2 || Z > 1) {
    Z = Z + 1;
  }
}
```

![image.png](image%2045.png)

### 2. 가능한 모든 경로 구하기

![image.png](image%2046.png)

위에서 보다시피, 단일경로로는 모든 분기를 거쳐갈 수 없습니다. 따라서 우리는 **경로를 합칠 것**입니다.

### 3. 분기 검증 기준을 만족하는 경로 선택

2개 이상의 경로를 묶어서 모든 분기를 지나칠 수 있는 최소 경로 단위를 구할 것입니다.

![image.png](image%2047.png)

## 분기 검증 기준의 문제

물론 훨씬 많은 오류가 발생할 수 있지만 그 중 위의 예제에서 찾을 수 있는 대표적인 문제점만 짚고 넘어갈 예정입니다.

### 위의 예제에서 or 연산인 경우

![image.png](image%2048.png)

경로 1, 4: 문장 (다)에서 Z>1를 Z<1로 코딩 실수를 해도 오류를 발견하지 못합니다.

- 개별 조건식이 or로 연결되어 있어 **둘 중 하나라도 T이면 다른 식이 무엇이든** 관계없이 조건문의 결과 값에 영향을 주지 않기 때문입니다.

### 위의 예제에서 and 연산인 경우

```jsx
if (score >= 90 && report >= 90)
  printf(“A”)
```

위 조건문에서 score < 90일 때, report >= 90을 report < 90로 코딩 실수를 해도 발견하지 못합니다.

- 두 개별 조건식이 **and로 연결**되어 있어, **둘 중 하나라도 F이면** 다른 식이 무엇이든 관계없이 조건문의 결과 값에 영향을 주지 않기 때문입니다.
- 해결 방법은 다음과 같다
    - 조건문 내의 개별 조건식에 대하여 각각 T와 F인 경우를 최소한 한 번씩 수행합니다.